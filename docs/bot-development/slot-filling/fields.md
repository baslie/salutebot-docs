---
title: "Заполнение слотов из запроса"
source_url: "https://github.com/baslie/salutebot-docs/blob/main/docs/bot-development/slot-filling/fields.md"
description: "Заполнение слотов из запроса для чат-ботов | Разработка чат-ботов"
reading_time: 1
badges: ["SaluteBot", "Code"]
toc:
  - title: "АтрибутТип"
    level: 2
    id: "atribut-tip"
  - title: "АтрибутОбязательность"
    level: 2
    id: "atribut-obyazatelnost"
  - title: "Массивы в слотах"
    level: 2
    id: "massivy-v-slotah"
---

<!-- Бейджи: SaluteBot | Code -->

# Заполнение слотов из запроса

Содержание раздела

* [Атрибут Тип](#атрибуттип)
* [Атрибут Обязательность](#атрибутобязательность)
* [Массивы в слотах](#массивы-в-слотах)

# Заполнение слотов из запроса

Обновлено 15 декабря 2023

[![](/assets/bot-development/slot-filling/fields/salutebot-new.png)
SaluteBot](../../overview.md)[![](/assets/bot-development/slot-filling/fields/Code.png)
Code](https://developers.sber.ru/docs/ru/va/code/overview)

Если рассматривать [`интент`](https://developers.sber.ru/docs/ru/va/code/sa-dsl/tags/intents-tags) как функцию, которую пользователь может вызвать, то `слот` является переменной, параметром этой функции.

Например, для интента `/Погода` примером фразы может быть «Погода в Лондоне сегодня» и два слота `City` и `Date`.
В этом случае в слот `City` попадет — Лондон, а в слот `Date` — сегодня.

При этом заполненные слоты будут переданы в сценарий в переменной `$parseTree._<ИмяСлота>`. В значении переменной будет ассоциированное значение, при его отсутствии — текст.

Использование заполненных слотов в сценарии:

```
state:
    intent!: /Погода
    a: Погода в {{ $parseTree._City }} на {{ $parseTree._Date }}
```

[Подробнее о заполнении слотов в интерфейсе Code](https://developers.sber.ru/docs/ru/va/chat/voice-interface/command-recognition/intents).

## Атрибут `Тип`

Каждый слот должен иметь `Тип`, который соответствует сущности `Тип = сущность`. Этот тип определяет тип данных, которые попадут в слот. Вы можете использовать как [системные, так и собственные сущности](https://developers.sber.ru/docs/ru/va/code/nlp/entities/overview).

Например, для слота `Date` с типом `@zb.datetime`: слово «сегодня» из запроса клиента попадет в сущность `@zb.datetime` и будет помещено в слот `Date`.

Если в интенте присутствует несколько слотов с одинаковым типом, то они будут заполнены последовательно.

Если нужно обработать произвольное количество слотов одного типа в запросе или переменные с разными типами сущностей, обращайтесь к переменной [`$entities`](https://developers.sber.ru/docs/ru/va/code/nlp/entities/overview), которая содержит все найденные сущности в исходном виде.

## Атрибут `Обязательность`

Каждый слот имеет атрибут `Обязательность`:

* Если слот обязателен и при этом уточняющие вопросы не указаны, то заполнение слота в ответе обязательно для срабатывания интента.
* Если слот обязателен и при этом уточняющие вопросы указаны, то интент сработает и без этого слота. Интент будет обработан модулем слот-филлинга, пользователю будут заданы уточняющие вопросы.

Перед работой со слот-филлинга ознакомьтесь с [заполнением слотов](https://developers.sber.ru/docs/ru/va/chat/voice-interface/command-recognition/intents).

## Массивы в слотах

Для обработки запросов с повторяющимися сущностями в сценарии слот `$parseTree._<ИмяСлота>` должен содержать массив.

Включите опцию **Массив**, чтобы в слот помещались все сущности данного типа, оформленные как массив.

Если опция **Массив**:

* **Не активна**: в слот помещается первое обработанное значение данной сущности.
* **Активна**: в слот помещаются все сущности данного типа, оформленные как массив. Если обнаружено только одно значение сущности, оно также оформляется как массив.

Заметили ошибку?

Выделите текст и нажмите `Ctrl` + `Enter`, чтобы сообщить нам о ней
